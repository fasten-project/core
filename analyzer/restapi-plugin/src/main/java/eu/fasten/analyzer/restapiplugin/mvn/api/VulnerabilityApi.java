package eu.fasten.analyzer.restapiplugin.mvn.api;

import eu.fasten.analyzer.restapiplugin.mvn.KnowledgeBaseConnector;
import eu.fasten.analyzer.restapiplugin.mvn.LazyIngestionProvider;
import eu.fasten.analyzer.restapiplugin.mvn.RestApplication;
import eu.fasten.core.data.Constants;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/mvn")
public class VulnerabilityApi {

    private final Logger logger = LoggerFactory.getLogger(getClass());

    @GetMapping(value = "/vulnerabilities", produces = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<String> getAllVulnerabilities(@RequestParam(required = false, defaultValue = "0") int offset,
                                                 @RequestParam(required = false, defaultValue = RestApplication.DEFAULT_PAGE_SIZE) int limit,
                                                 @RequestParam(required = false, defaultValue = "") List<String> attributes) {

        var statements = KnowledgeBaseConnector.kbDao.getAllVulnerabilities(offset, limit);
        JSONArray vulnerabilities = new JSONArray(statements);
        var result = getStatementsAttributes(vulnerabilities, attributes)
                .toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @GetMapping(value = "/vulnerabilities/{external_id}", produces = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<String > getVulnerability(@PathVariable("external_id") String externalId,
                                             @RequestParam(required = false, defaultValue = "") List<String> attributes) {

        var statement = KnowledgeBaseConnector.kbDao.getVulnerability(externalId);
        if (statement == null) {
            return new ResponseEntity<>("Vulnerability not found", HttpStatus.NOT_FOUND);
        }
        JSONObject vulnerability = new JSONObject(statement);
        JSONObject needed = getStatementAttributes(vulnerability.getJSONObject("statement"), attributes);
        vulnerability.put("statement", needed);
        var result = vulnerability.toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @GetMapping(value = "/vulnerabilities/{external_id}/purls", produces = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<String> getPurls(@RequestParam(required = false, defaultValue = "0") int offset,
                                    @RequestParam(required = false, defaultValue = RestApplication.DEFAULT_PAGE_SIZE) int limit,
                                    @PathVariable("external_id") String externalId) {

        var result = KnowledgeBaseConnector.kbDao.getPurls(externalId, offset, limit);
        if (result == null) {
            return new ResponseEntity<>("Vulnerability not found", HttpStatus.NOT_FOUND);
        }
        result = result.replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @GetMapping(value = "/vulnerabilities/{external_id}/callables", produces = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<String> getVulnerableCallables(@RequestParam(required = false, defaultValue = "0") int offset,
                                                  @RequestParam(required = false, defaultValue = "1000") int limit,
                                                  @PathVariable("external_id") String externalId) {

        var uriMap = KnowledgeBaseConnector.kbDao.getVulnerableCallables(externalId, offset, limit);
        if (uriMap == null) {
            return new ResponseEntity<>("Vulnerability not found", HttpStatus.NOT_FOUND);
        }
        var json = new JSONObject();
        uriMap.forEach((key, value) -> json.put(String.valueOf(key), value));
        var result = json.toString();
        result = result.replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @PostMapping(value = "/vulnerabilities/coordinates", produces = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<String> getCoordinatesVulnerabilities(@RequestBody List<String> mavenCoordinates,
                                                         @RequestParam(required = false, defaultValue = "") List<String> attributes) {

        logger.info("Received a list of Maven coordinates");
        var jsonArray = new JSONArray();
        mavenCoordinates.stream().map(c -> {
            var package_name = c.split(Constants.mvnCoordinateSeparator)[0]
                    + Constants.mvnCoordinateSeparator
                    + c.split(Constants.mvnCoordinateSeparator)[1];
            var package_version = c.split(Constants.mvnCoordinateSeparator)[2];
            var vulnerabilities = "";
            if (!KnowledgeBaseConnector.kbDao.assertPackageExistence(package_name, package_version)) {
                try {
                    LazyIngestionProvider.ingestArtifactWithDependencies(package_name, package_version);
                    logger.info("Coordinate " + c + " not found, but should be processed soon. Try again later");
                } catch (Exception e) {
                    logger.info("Cannot find coordinate " + c + ": " +e.getMessage());
                }
            } else {
                var statements = KnowledgeBaseConnector.kbDao
                        .getPackageVersionVulnerabilities(package_name, package_version, false);
                JSONArray vul = new JSONArray(statements);
                vulnerabilities = getStatementsAttributes(vul, attributes).toString();
            }
            var json = new JSONObject();
            json.put(c, vulnerabilities);
            return json;
        }).forEach(jsonArray::put);
        var result = jsonArray.toString();
        result = result.replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @GetMapping(value = "/packages/{pkg}/{pkg_ver}/vulnerabilities", produces = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<String> getPackageVersionVulnerabilities(@PathVariable("pkg") String package_name,
                                                            @PathVariable("pkg_ver") String package_version,
                                                            @RequestParam(required = false, defaultValue = "") List<String> attributes) {
        
        if (!KnowledgeBaseConnector.kbDao.assertPackageExistence(package_name, package_version)) {
            try {
                LazyIngestionProvider.ingestArtifactWithDependencies(package_name, package_version);
            } catch (IllegalArgumentException | IOException e) {
                return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);
            }
            return new ResponseEntity<>("Package version not found, but should be processed soon. Try again later", HttpStatus.CREATED);
        }
        var statements = KnowledgeBaseConnector.kbDao.getPackageVersionVulnerabilities(package_name, package_version, true);
        JSONArray vulnerabilities = new JSONArray(statements);
        var result = getStatementsAttributes(vulnerabilities, attributes)
                .toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @PostMapping(value = "/vulnerabilities/purls", produces = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<String> getPurlVulnerabilities(@RequestBody String purl,
                                                  @RequestParam(required = false, defaultValue = "") List<String> attributes) {
        if (!KnowledgeBaseConnector.kbDao.assertPurlExistence(purl)) return new ResponseEntity<>("", HttpStatus.OK);
        var statements = KnowledgeBaseConnector.kbDao.getPurlVulnerabilities(purl, true);
        JSONArray vulnerabilities = new JSONArray((statements));
        var result = getStatementsAttributes(vulnerabilities, attributes)
                .toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    private JSONObject getStatementAttributes(JSONObject statement, List<String> attributes) {
    var neededInfo = new JSONObject();
    if (attributes.size() > 0) {
        for (var attribute : statement.keySet()) {
            if (attributes.contains(attribute)) {
                neededInfo.put(attribute, statement.get(attribute));
            }
        }
    } else {
        neededInfo = statement;
    }
    return neededInfo;
}

    private JSONArray getStatementsAttributes(JSONArray statements, List<String> attributes) {
        JSONArray vulnInfo = new JSONArray();
        statements.forEach(v -> {
            JSONObject vJson = (JSONObject) v;
            JSONObject needed = getStatementAttributes(vJson.getJSONObject("statement"), attributes);
            vJson.put("statement", needed);
            vulnInfo.put(vJson);
        });
        return vulnInfo;
    }
}
