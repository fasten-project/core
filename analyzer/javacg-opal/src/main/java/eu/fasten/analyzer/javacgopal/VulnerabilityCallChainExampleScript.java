package eu.fasten.analyzer.javacgopal;

import com.google.common.collect.BiMap;
import eu.fasten.analyzer.javacgopal.data.CallGraphConstructor;
import eu.fasten.analyzer.javacgopal.data.PartialCallGraph;
import eu.fasten.core.data.Constants;
import eu.fasten.core.data.DirectedGraph;
import eu.fasten.core.data.ExtendedRevisionJavaCallGraph;
import eu.fasten.core.data.callableindex.RocksDao;
import eu.fasten.core.data.callableindex.utils.CallableIndexChecker;
import eu.fasten.core.data.metadatadb.codegen.tables.Callables;
import eu.fasten.core.data.metadatadb.codegen.tables.Modules;
import eu.fasten.core.data.metadatadb.codegen.tables.PackageVersions;
import eu.fasten.core.data.metadatadb.codegen.tables.Packages;
import eu.fasten.core.data.opal.MavenCoordinate;
import eu.fasten.core.data.opal.exceptions.MissingArtifactException;
import eu.fasten.core.data.opal.exceptions.OPALException;
import eu.fasten.core.maven.GraphMavenResolver;
import eu.fasten.core.maven.ResolutionStrategy;
import eu.fasten.core.maven.ShrinkWrapResolution;
import eu.fasten.core.maven.data.Revision;
import eu.fasten.core.merge.CGMerger;
import eu.fasten.core.merge.CallGraphUtils;
import it.unimi.dsi.fastutil.Pair;
import it.unimi.dsi.fastutil.longs.LongLongPair;
import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.jgrapht.GraphPath;
import org.jgrapht.alg.shortestpath.AllDirectedPaths;
import org.jooq.DSLContext;
import org.json.JSONObject;
import org.rocksdb.RocksDBException;
import picocli.CommandLine;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import me.tongfei.progressbar.ProgressBar;


@CommandLine.Command(name = "eu.fasten.analyzer.javacgopal.VulnerabilityCallChainExampleScript")
public class VulnerabilityCallChainExampleScript implements Runnable {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityCallChainExampleScript.class);
    public static final Integer MAXPATHSIZE = 20;

    @CommandLine.Option(names = {"-c", "--callable-index-path"},
        paramLabel = "INDEX_PATH",
        required = true,
        description = "Path to the callable index")
    String callableIndexPath;

    @CommandLine.Option(names = {"-d", "--database"},
        paramLabel = "DB_URL",
        description = "Database URL for connection",
        defaultValue = "jdbc:postgresql:fasten_java")
    String metadataDbUrl;

    @CommandLine.Option(names = {"-u", "--user"},
        paramLabel = "DB_USER",
        description = "Database user name",
        defaultValue = "fastenro")
    String metadataDbUser;

    @CommandLine.Option(names = {"-o", "--outputPath"},
        paramLabel = "OUTPUT",
        description = "The path to the directory to write the results")
    String outputDir;

    @CommandLine.Option(names = {"-dg", "--depGraphPath"},
        paramLabel = "DEPGRAPH_PATH",
        description = "The path to the dependency graph")
    String depGraphPath;

    public static void main(String[] args) {
        final int exitCode =
            new CommandLine(new VulnerabilityCallChainExampleScript()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public void run() {

        checkIfArgumentsAreProvided(this.outputDir, this.callableIndexPath, this.metadataDbUrl,
            this.metadataDbUser);

        var rocksDb = CallableIndexChecker.connectToReadOnlyRocksDB(this.callableIndexPath);
        var metadataDb =
            CallableIndexChecker.connectToPostgres(this.metadataDbUrl, this.metadataDbUser);
        var graphResolver = buildResolver(metadataDb);
        var shrinkWrapResolver = new ShrinkWrapResolution();

        var vulRevisions = queryVulRevisions(metadataDb);
        logger.info("Retrieved {} vulnerable packages, writing them to file.", vulRevisions.size());
        writeVulCoordsToFile(vulRevisions);

        final var dependentsMap = getDependents(graphResolver, vulRevisions);
        logger.info("Resolved dependents, writing them to file.");
        writeDependentsToFile(dependentsMap);

        ProgressBar vulProgress = new ProgressBar("Vulnerabilities", dependentsMap.size());
        vulProgress.start();
        int counter = 0;
        for (final var vulDependents : dependentsMap.entrySet()) {

            final var vulCallables = queryCallableVuls(metadataDb, vulDependents.getKey());
            if (vulCallables.isEmpty()) {
                counter++;
                continue;
            }
            var len = vulDependents.getValue().size();
            for (int i = 0; i < len; i++) {
                var dependent = vulDependents.getValue().get(i);
                System.out.print(String.format("%s/%s", i, len));
                try {
                    final var deps =
                        resolveDeps(metadataDb, shrinkWrapResolver, dependent);
//                    final var merger = new CGMerger(ids, metadataDb, rocksDb);
                    logger.info("resolved dependencies of {}, {} packages", dependent.toCoordinate(),
                        deps.size());
                    List<ExtendedRevisionJavaCallGraph> depSet = new ArrayList<>();
                    var dependentCG = readGraphFromFile(dependent);
                    var vulCG = readGraphFromFile(vulDependents.getKey());

                    deps.parallelStream().forEach(dep -> {
                        ExtendedRevisionJavaCallGraph cg = readGraphFromFile(dep);
                        if (cg != null) {
                            depSet.add(cg);
                        }
                    });
                    if (dependentCG == null || vulCG == null) {
                        continue;
                    }

                    depSet.add(vulCG);
                    depSet.add(dependentCG);
                    logger.info("Loaded {} dependencies.", depSet.size());

                    final var merger = new CGMerger(depSet);
                    final var mergedGraph = merger.mergeAllDeps();

                    logger.info("Merged {} nodes and {} edges.", mergedGraph.numNodes(),
                        mergedGraph.numArcs());

                    final var vulPaths = getVulPaths(rocksDb, vulCallables, dependent,
                        mergedGraph, merger);
                    if (vulPaths == null || vulPaths.isEmpty()) {
                        continue;
                    }
                    logger.info("{} vulnerable paths were found.", vulPaths.size());
                    final var uris = merger.getAllUrisFromDB(mergedGraph);
                    writeVulPathToFile(dependent, vulPaths, uris);
                } catch (Exception e){
                    logger.error("An exception occurred while finding vulchain for {}",
                        dependent.toString(), e);
                }
            }
            vulProgress.step();
        }
        logger.info("No vulnerable callable for {} packages", counter);
        vulProgress.stop();

    }

    private ExtendedRevisionJavaCallGraph readGraphFromFile(Revision dep) {
        final var depPath = Paths.get(getFilePath(dep));
        String reader = null;
        if (Files.exists(depPath)) {
            try {
                reader = Files.readString(depPath);
            } catch (IOException e) {
                return null;
            }
        }
        if (reader == null) {
            return null;
        }
        return new ExtendedRevisionJavaCallGraph(new JSONObject(reader));
    }

    private void generateAndAddCG(List<ExtendedRevisionJavaCallGraph> depSet, Revision dep)
        throws MissingArtifactException, OPALException {
        var coord = MavenCoordinate.fromString(dep.toCoordinate(), "jar");
        var depFile =
            new MavenCoordinate.MavenResolver().downloadArtifact(coord,
            "https://repo1.maven.org/maven2/");
        var cg = new PartialCallGraph(new CallGraphConstructor(depFile,"",
            "RTA"));

        depSet.add(ExtendedRevisionJavaCallGraph.extendedBuilder()
            .graph(cg.getGraph())
            .product(coord.getProduct())
            .version(coord.getVersionConstraint())
            .classHierarchy(cg.getClassHierarchy())
            .nodeCount(cg.getNodeCount())
            .build());
    }

    private String getFilePath(Revision dep) {
        return "/mnt/fasten/mvn/" + dep.product().groupId.substring(0, 1)+"/"+dep.groupId+"/"+dep.groupId+"_"+dep.artifactId+"_"+dep.version+".json";
    }

    private Map<Pair<Long, Long>, List<GraphPath<Long, LongLongPair>>> getVulPaths(RocksDao rocksDb,
                                                                                   List<Long> vulCallables,
                                                                                   Revision dependent,
                                                                                   DirectedGraph mergedGraph,
                                                                                   CGMerger merger) {

        Map<Pair<Long, Long>, List<GraphPath<Long, LongLongPair>>> vulPaths = new HashMap<>();
//        DirectedGraph dependentCG = null;
//        try {
//            dependentCG = rocksDb.getGraphData(dependent.id);
//        } catch (RocksDBException e) {
//            logger.warn("Failed to fetch the data of" + dependent.id + "package", e);
//        }
//        if (dependentCG == null) {
//            return null;
//        }
        BiMap<Long, String> uris = merger.getAllUris();
        var appPrefix = String.format("%s$%s","fasten://mvn!", dependent.getProductString());
        logger.info("Looking for paths that start from {}", appPrefix);
        for (Long vulNode : vulCallables) {
            if (!mergedGraph.containsVertex(vulNode)) {
                continue;
            }
            mergedGraph.nodes().longParallelStream()
                .filter(nodeId -> uris.get(nodeId).startsWith(appPrefix))
                .filter(nodeId -> goesOutside(nodeId, mergedGraph, uris, appPrefix))
                .forEach(applicationNodeId ->  {
                    logger.info(
                        "########### Source and target are in the merged graph ##########");
                    final var pathFinder = new AllDirectedPaths<>(mergedGraph);
                    final var paths = pathFinder.getAllPaths(applicationNodeId,
                        vulNode, true, MAXPATHSIZE);
                    if (paths != null && !paths.isEmpty()) {
                        vulPaths.put(Pair.of(applicationNodeId, vulNode), paths);
                    }
            });
        }
        return vulPaths;
    }

    private boolean goesOutside(long nodeId, DirectedGraph mergedGraph, BiMap<Long, String> uris,
                                String appPrefix) {
        for (LongLongPair longLongPair : mergedGraph.outgoingEdgesOf(nodeId)) {
            if (!uris.get(longLongPair.rightLong()).startsWith(appPrefix)) {
                return true;
            }
        }
        return false;
    }

    private boolean hasExternalEdge(
        DirectedGraph mergedGraph, DirectedGraph dependentCG, Long dependentNode) {
        if (mergedGraph.containsVertex(dependentNode)) {
            for (LongLongPair longLongPair : mergedGraph.outgoingEdgesOf(dependentNode)) {
                if (!dependentCG.containsVertex(longLongPair.rightLong())) {
                    return true;
                }
            }
        }
        return false;
    }

    private Set<Revision> resolveDeps(DSLContext metadataDb,
                                      ResolutionStrategy dependencyGraphResolver,
                                      Revision dependent) {
        final var dependencySet =
            dependencyGraphResolver.resolve(dependent, true);
        addIDsToRevisionsWithoutID(metadataDb, dependencySet);
//        return dependencySet.stream().map(r -> r.id).collect(Collectors.toSet());
        return dependencySet;
    }

    private void writeVulPathToFile(Revision dependent,
                                    Map<Pair<Long, Long>, List<GraphPath<Long, LongLongPair>>> vulPaths,
                                    BiMap<Long, String> uris) {
        final var pckgDir = this.outputDir + "/" + dependent.toString();
        if (new File(pckgDir).mkdir()) {
            List<String[]> content = getContent(vulPaths, uris);
            try {
                CallGraphUtils.writeToCSV(content, pckgDir + "/vulPaths.csv");
            } catch (IOException e) {
                logger.error("Error happened while writing vul paths of package" +
                    dependent.toString(), e);
            }
        }
    }

    private List<String[]> getContent(
        Map<Pair<Long, Long>, List<GraphPath<Long, LongLongPair>>> vulPaths,
        BiMap<Long, String> uris) {
        List<String[]> content = new ArrayList<>();
        content.add(new String[] {"source", "target", "paths"});
        for (final var sourceTargetPath : vulPaths.entrySet()) {
            for (final var path : sourceTargetPath.getValue()) {
                final var pathsIDs = path.getEdgeList();
                final var key = sourceTargetPath.getKey();
                var sourceId = key.left();
                var targetId = key.right();
                var sourceUri = uris.get(sourceId);
                var targetUri = uris.get(targetId);
                var delimiter = "";
                StringBuilder paths = new StringBuilder();
                for (LongLongPair pathsID : pathsIDs) {
                    paths.append(delimiter);
                    delimiter = ",";
                    var leftID = pathsID.leftLong();
                    var leftUri = uris.get(leftID);
                    paths.append(leftID).append(";").append(leftUri);
                    paths.append("->");
                    var rightId = pathsID.rightLong();
                    var rightUri = uris.get(rightId);
                    paths.append(rightId).append(";").append(rightUri);
                }
                content.add(new String[] {sourceId + ";" + sourceUri, targetId + ";" + targetUri,
                    paths.toString()});
            }
        }
        return content;
    }

    private void addIDsToRevisionsWithoutID(
        DSLContext metadataDb, Set<Revision> dependencySet) {
        for (Revision revision : dependencySet) {
            if (revision.id == 0) {
                final var id = metadataDb
                    .select(PackageVersions.PACKAGE_VERSIONS.ID)
                    .from(PackageVersions.PACKAGE_VERSIONS).join(Packages.PACKAGES)
                    .on(PackageVersions.PACKAGE_VERSIONS.PACKAGE_ID.eq(Packages.PACKAGES.ID))
                    .where(PackageVersions.PACKAGE_VERSIONS.VERSION.eq(revision.version.toString()))
                    .and(Packages.PACKAGES.PACKAGE_NAME
                        .eq(revision.groupId + ":" + revision.artifactId))
                    .and(Packages.PACKAGES.FORGE.eq(Constants.mvnForge))
                    .fetchAny();
                if (id != null) {
                    revision.id = id.getValue(PackageVersions.PACKAGE_VERSIONS.ID, Long.class);
                }
            }
        }
    }

    private Map<Revision, ObjectLinkedOpenHashSet<Revision>> getDependents(
        final GraphMavenResolver resolver,
        final List<Revision> vulCoords) {
        Map<Revision, ObjectLinkedOpenHashSet<Revision>> dependentsMap = new HashMap<>();
        int counter = 0;
        for (final var revision : vulCoords) {
            ObjectLinkedOpenHashSet<Revision> dependents = null;
            try {
                dependents = resolver.resolveDependents(revision, true);
            } catch (RuntimeException e) {
                counter++;
            }
            if (dependents != null) {
                dependentsMap.put(revision, dependents);
            }
        }
        logger.warn("Failed to fetch dependents of {} vul packages, perhaps they are not in the DB",
            counter);
        return dependentsMap;
    }

    private List<Long> queryCallableVuls(final DSLContext metadataDb,
                                         final Revision revison) {
        logger.info("getting vulnerable callables of package version {}", revison.toString());

        var modules =
            metadataDb.select(Modules.MODULES.ID).from(Modules.MODULES)
                .where(Modules.MODULES.PACKAGE_VERSION_ID.eq(revison.id)).fetch()
                .intoSet(Modules.MODULES.ID);
        if (modules.size() > 0) {
            var modulesString = modules.stream()
                .map(Object::toString).collect(Collectors.joining(", "));

            String sql =
                "SELECT id FROM callables WHERE callables.module_id IN (" + modulesString + ")" +
                    " AND metadata -> 'vulnerabilities' IS NOT NULL";

            return metadataDb.fetch(sql).getValues(Callables.CALLABLES.ID, Long.class);
        }
        return Collections.emptyList();
    }


    private void writeDependentsToFile(
        Map<Revision, ObjectLinkedOpenHashSet<Revision>> dependentsMap) {

        List<String[]> content = new ArrayList<>();
        content.add(new String[] {"package", "dependents"});
        for (final var dependents : dependentsMap.entrySet()) {
            content.add(new String[] {dependents.getKey().toString(),
                dependents.getValue().stream().map(Revision::toString).collect(
                    Collectors.joining(";"))});
        }

        try {
            CallGraphUtils.writeToCSV(content, this.outputDir + "/vulnerableDependents.csv");
        } catch (IOException e) {
            throw new RuntimeException("Failed to write dependents map to file", e);
        }
    }

    private GraphMavenResolver buildResolver(DSLContext metadataDb) {
        var resolver = new GraphMavenResolver();
        try {
            resolver.buildDependencyGraph(metadataDb, this.depGraphPath);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return resolver;
    }

    private void writeVulCoordsToFile(List<Revision> packageVersionCoords) {

        try {
            final var coords = String.join("\n",
                packageVersionCoords.stream().map(Revision::toString).collect(Collectors.toSet()));
            CallGraphUtils
                .writeToFile(this.outputDir + "/vulnerablePackageVersionCoords.txt", coords);
        } catch (IOException e) {
            throw new RuntimeException("Failed to write vulnerable coords to file", e);
        }
    }

    private void checkIfArgumentsAreProvided(String... arguments) {
        for (String argument : arguments) {
            if (argument == null) {
                throw new RuntimeException("Please provide all arguments");
            }
        }

    }

    private List<Revision> queryVulRevisions(DSLContext metadataDb) {
        logger.info("getting vulnerable package version ids ...");

        String sql =
            "select CONCAT(packages.package_name,':', package_versions.version), package_versions.created_at, package_versions.id from package_versions JOIN packages on (packages.id = package_versions.package_id)\n" +
                "WHERE package_versions.metadata -> 'vulnerabilities' IS NOT NULL";

        List<Revision> vulRevisions = new ArrayList<>();
        metadataDb.fetch(sql).forEach(record -> {
            final var coord = (String) record.get(0);
            if (coord != null) {
                final var gav = coord.split(":");
                final var timestamp = (Timestamp) record.get(1);
                final var id = (Long) record.get(2);
                Revision currentRevision;
                if (id != null) {
                    currentRevision = new Revision(id, gav[0], gav[1], gav[2], timestamp);
                } else {
                    currentRevision = new Revision(gav[0], gav[1], gav[2], timestamp);
                }
                vulRevisions.add(currentRevision);
            }
        });
        return vulRevisions;
    }

}

